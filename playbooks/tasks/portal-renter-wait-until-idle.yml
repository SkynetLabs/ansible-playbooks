# Wait 5 minutes for any small uploads and downloads to finish. After 5 minutes,
# it is likely that it is a large upload in which case it is safe to take the
# server down as the large upload will continue on another server. Or it is a
# large download which can also be resumed on another server.

# Check if sia container is running.
- name: Check sia container is running
  community.docker.docker_container_info:
    name: sia
  register: sia_docker_container_result

# Get the ip address for the sia container
- name: Get sia service IP inside docker compose network
  command: docker inspect -f "{% raw %}{{ range.NetworkSettings.Networks }}{{ .IPAddress }}{{ end }}{% endraw %}" sia
  register: sia_ip_result

- block:
    - name: Set renter wait start time
      set_fact:
        renter_wait_start_time: "{{ (lookup('pipe', 'date +%s') | int) if renter_wait_start_time is not defined else renter_wait_start_time }}"

    - name: Get skyd /renter endpoint result
      command: docker run --rm --network="container:sia" "{{ curl_docker_image }}" --silent --show-error -A "Sia-Agent" "http://{{ sia_ip_result.stdout }}:9980/renter"
      register: renter_get_result

    - name: Calculate renter memory to check for active registry access, downloads and uploads
      vars:
        # get renter output, convert to json, and get the memorystatus field
        output: "{{ renter_get_result.stdout | from_json }}"
        memorystatus: "{{ output.memorystatus }}"
        # assign registry variables
        registry_available: "{{ memorystatus.registry.available }}"
        registry_priorityavailable: "{{ memorystatus.registry.priorityavailable }}"
        registry_base: "{{ memorystatus.registry.base }}"
        registry_prioritybase: "{{ memorystatus.registry.prioritybase }}"
        registry_requested: "{{ memorystatus.registry.requested }}"
        registry_priorityrequested: "{{ memorystatus.registry.priorityrequested }}"
        # assign download variables
        userdownload_available: "{{ memorystatus.userdownload.available }}"
        userdownload_priorityavailable: "{{ memorystatus.userdownload.priorityavailable }}"
        userdownload_base: "{{ memorystatus.userdownload.base }}"
        userdownload_prioritybase: "{{ memorystatus.userdownload.prioritybase }}"
        userdownload_requested: "{{ memorystatus.userdownload.requested }}"
        userdownload_priorityrequested: "{{ memorystatus.userdownload.priorityrequested }}"
        # assign upload variables
        userupload_available: "{{ memorystatus.userupload.available }}"
        userupload_priorityavailable: "{{ memorystatus.userupload.priorityavailable }}"
        userupload_base: "{{ memorystatus.userupload.base }}"
        userupload_prioritybase: "{{ memorystatus.userupload.prioritybase }}"
        userupload_requested: "{{ memorystatus.userupload.requested }}"
        userupload_priorityrequested: "{{ memorystatus.userupload.priorityrequested }}"
        # check if any memory is being requested for registry, download and uploads
        renter_requested_registry: "{{ (registry_requested | int + registry_priorityrequested | int) > 0 }}"
        renter_requested_download: "{{ (userdownload_requested | int + userdownload_priorityrequested | int) > 0 }}"
        renter_requested_upload: "{{ (userupload_requested | int + userupload_priorityrequested | int) > 0 }}"
        # check if any memory is being used for registry, download and uploads
        renter_in_use_registry: "{{ (registry_base | int + registry_prioritybase | int - registry_available | int - registry_priorityavailable | int > 0) }}"
        renter_in_use_download: "{{ (userdownload_base | int + userdownload_prioritybase | int - userdownload_available | int - userdownload_priorityavailable | int > 0) }}"
        renter_in_use_upload: "{{ (userupload_base | int + userupload_prioritybase | int - userupload_available | int - userupload_priorityavailable | int > 0) }}"
      set_fact:
        # register renter busy status
        renter_requested_registry: "{{ renter_requested_registry }}"
        renter_requested_download: "{{ renter_requested_download }}"
        renter_requested_upload: "{{ renter_requested_upload }}"
        renter_in_use_registry: "{{ renter_in_use_registry }}"
        renter_in_use_download: "{{ renter_in_use_download }}"
        renter_in_use_upload: "{{ renter_in_use_upload }}"
        renter_busy: "{{ renter_requested_registry or renter_requested_download or renter_requested_upload or renter_in_use_registry or renter_in_use_download or renter_in_use_upload }}"
      when:
        - renter_get_result.rc == 0 and renter_get_result.stderr == ""

    - name: "Check if renter is idle"
      fail:
        msg: Renter still busy with registry, downloads or uploads.
      when:
        - renter_get_result.rc == 0 and renter_get_result.stderr == ""
        - renter_busy

    - name: renter_wait_start_time
      ansible.builtin.debug:
        var: renter_wait_start_time

    - name: renter_get_result.rc
      ansible.builtin.debug:
        var: renter_get_result.rc

    - name: renter_get_result.stderr
      ansible.builtin.debug:
        var: renter_get_result.stderr

    - name: renter_requested_registry
      ansible.builtin.debug:
        var: renter_requested_registry

    - name: renter_requested_download
      ansible.builtin.debug:
        var: renter_requested_download

    - name: renter_requested_upload
      ansible.builtin.debug:
        var: renter_requested_upload

    - name: renter_in_use_registry
      ansible.builtin.debug:
        var: renter_in_use_registry

    - name: renter_in_use_download
      ansible.builtin.debug:
        var: renter_in_use_download

    - name: renter_in_use_upload
      ansible.builtin.debug:
        var: renter_in_use_upload

    - name: renter_busy
      ansible.builtin.debug:
        var: renter_busy

  rescue:
    - name: "Retry renter check"
      include_tasks: tasks/portal-renter-wait-until-idle.yml
      # when:
      #   - "{{ (lookup('pipe', 'date +%s') | int) - renter_wait_start_time < renter_busy_check_wait_secs }}"

  # Do not wait if sia container is not running or is restarting
  when:
    - sia_docker_container_result.exists
    - sia_docker_container_result.container is defined
    - sia_docker_container_result.container.State.Running
    - not sia_docker_container_result.container.State.Restarting
    - sia_ip_result.rc == 0
